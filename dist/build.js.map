{"version":3,"names":[],"mappings":"","sources":["build.js"],"sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n\"use strict\";\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar _menu = require(\"./menu\");\n\nvar _menu2 = _interopRequireDefault(_menu);\n\nvar _debug = require(\"./debug\");\n\nvar _debug2 = _interopRequireDefault(_debug);\n\nvar camera = undefined,\n    controls = undefined,\n    effect = undefined,\n    clock = undefined,\n    scene = undefined,\n    renderer = undefined,\n    container = null;\n\nfunction init() {\n  clock = new THREE.Clock();\n  container = $('#container');\n\n  // Canvas Size\n  var WIDTH = container.width(),\n      HEIGHT = container.height();\n\n  // Camera Attributes\n  var VIEW_ANGLE = 90,\n      // FOV - How much can the camera see\n  ASPECT = WIDTH / HEIGHT,\n      // Aspect ratio\n  NEAR = 0.001,\n      // Near plane\n  FAR = 700; // Far plane\n\n  // Setup renderer and append to DOM\n  renderer = new THREE.WebGLRenderer({ alpha: false });\n  renderer.setSize(WIDTH, HEIGHT);\n  renderer.setClearColor(0x000000, 1);\n  container.append(renderer.domElement);\n\n  // Setup the camera\n  camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);\n  camera.position.set(0, 10, 0);\n\n  // Setup the scene\n  scene = new THREE.Scene();\n\n  // Add Camera\n  scene.add(camera);\n\n  // Setup orbital controls\n  controls = new THREE.OrbitControls(camera, container.get(0));\n  controls.enableZoom = false;\n  controls.target.set(camera.position.x + 0.1, camera.position.y, camera.position.z);\n\n  // Setup VR effect\n  effect = new THREE.StereoEffect(renderer);\n  effect.setSize(WIDTH, HEIGHT);\n\n  // Setup mobile device controls\n  function setOrientationControls(e) {\n    if (!e.alpha) {\n      return;\n    }\n\n    controls = new THREE.DeviceOrientationControls(camera, true);\n    controls.connect();\n    controls.update();\n\n    // element.addEventListener('click', fullscreen, false);\n\n    window.removeEventListener('deviceorientation', setOrientationControls, true);\n  }\n  window.addEventListener('deviceorientation', setOrientationControls, true);\n\n  // Add some light to the scene\n  var light = new THREE.HemisphereLight(0xffffff, 0xFFFFFF, 1);\n  scene.add(light);\n\n  var geometry = new THREE.SphereGeometry(501, 60, 40);\n  geometry.scale(-1, 1, 1);\n\n  var material2 = new THREE.MeshBasicMaterial({\n    map: THREE.ImageUtils.loadTexture('img/landscape.jpg')\n  });\n\n  var mesh = new THREE.Mesh(geometry, material2);\n\n  scene.add(mesh);\n}\n\nfunction resize() {\n  var width = container.width();\n  var height = container.height();\n\n  camera.aspect = width / height;\n  camera.updateProjectionMatrix();\n\n  renderer.setSize(width, height);\n  effect.setSize(width, height);\n}\n\nfunction update(dt) {\n  resize();\n\n  camera.updateProjectionMatrix();\n\n  controls.update(dt);\n}\n\nfunction render() {\n  effect.render(scene, camera);\n}\n\nfunction animate(t) {\n  requestAnimationFrame(animate);\n\n  update(clock.getDelta());\n  render(clock.getDelta());\n}\n\ninit();\nanimate();\n\n},{\"./debug\":2,\"./menu\":3}],2:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Debug = function Debug(scene) {\n  _classCallCheck(this, Debug);\n\n  var debugaxis = function debugaxis(axisLength) {\n    //Shorten the vertex function\n    function v(x, y, z) {\n      return new THREE.Vector3(x, y, z);\n    }\n\n    //Create axis (point1, point2, colour)\n    function createAxis(p1, p2, color) {\n      var line,\n          lineGeometry = new THREE.Geometry(),\n          lineMat = new THREE.LineBasicMaterial({ color: color });\n      lineGeometry.vertices.push(p1, p2);\n      line = new THREE.Line(lineGeometry, lineMat);\n      scene.add(line);\n    }\n\n    createAxis(v(-axisLength, 0, 0), v(axisLength, 0, 0), 0xFF0000);\n    createAxis(v(0, -axisLength, 0), v(0, axisLength, 0), 0x00FF00);\n    createAxis(v(0, 0, -axisLength), v(0, 0, axisLength), 0x0000FF);\n  };\n\n  debugaxis(100);\n};\n\nexports[\"default\"] = Debug;\nmodule.exports = exports[\"default\"];\n\n},{}],3:[function(require,module,exports){\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nwindow.textMesh = null;\nwindow.textGeom = null;\n\nvar Menu = (function () {\n  function Menu() {\n    _classCallCheck(this, Menu);\n  }\n\n  _createClass(Menu, [{\n    key: \"start\",\n    value: function start(scene) {\n      var material = new THREE.MeshPhongMaterial({\n        color: 0xFFFFFF\n      });\n      textGeom = new THREE.TextGeometry(\"WELCOME TO DEGISPACE\", {\n        font: \"8bit\"\n      });\n      textMesh = new THREE.Mesh(textGeom, material);\n      textMesh.position.set(-125, 70, 0);\n      textGeom.rotateX(-25 * (Math.PI / 180));\n      textGeom.scale(0.1, 0.1, 0.1);\n\n      scene.add(textMesh);\n\n      textGeom.computeBoundingBox();\n    }\n  }]);\n\n  return Menu;\n})();\n\nexports[\"default\"] = Menu;\nmodule.exports = exports[\"default\"];\n\n},{}]},{},[1,2,3]);\n"],"file":"build.js","sourceRoot":"/source/"}